import { useState } from "react";

import Form from 'react-bootstrap/Form';
import Col from 'react-bootstrap/Col';

import PlanComparison from "../PlanComparison/PlanComparison";
import QueryVisualizer from "../QueryVisualizer/QueryVisualizer";

import styles from "./FormOutput.module.css";

const FormOutput = (props) => {

  const [planSelected, setPlanSelected] = useState([0, props.output["best_plan_id"]])
  // const [planSelected, setPlanSelected] = useState([0, 1])

  // Render alternative plan selection
  const renderAlternativeSelector = () => {
    if (props.output["error"] === false && JSON.stringify(props.output["data"]) !== JSON.stringify({})) {
      return (
        Object.keys(props.output["data"]).map((key) => {
          if (key === 0 || key === "0") {
            return (
              <option key={key} value={key}>Original plan</option>
            )
          }
          else {
            return (
              <option key={key} value={key}>Alternative plan {key}</option>
            )
          }
        })
      );
    }
    else {
      return <option>No plans available</option>;
    }
  }

  // Changes which plan is selected to compare
  const handleSelect = (planId, event) => {
    if (planId === 0) {
      setPlanSelected((oldState) => {
        let newState = [...oldState];
        newState[0] = event.target.value;
        return (newState);
      })
    }
    else {
      setPlanSelected((oldState) => {
        let newState = [...oldState];
        newState[1] = event.target.value;
        return (newState);
      })
    }
  }

  const parseExplanation = (planId) => {
    if (props.output["error"] === false && props.output["data"].hasOwnProperty(planId)) {
      return (
        <ol>
          {props.output["data"][planId]["explanation"].map((step, index) => {
            return (
              <li key={index}>{step}</li>
            )
          })}
        </ol >
      );
    }
    else {
      return (
        <div className={styles.explanationLoadingWrapper}>Waiting for data...</div>
      );
    }
  }

  const parseOptimalPlanExplanation = () => {
    if (props.output["best_plan_id"] === null) {
      return (
        <p>No plans available. Please send a query first.</p>
      )
    }
    if (props.output["best_plan_id"] === 0) {
      return (
        <p>The estimated cost per row of the original QEP generated by the input query is the lowest among all plans that are different from the original QEP in the neighbouring selectivity space of the predicates that have been varied.
        This implies that PostgreSQL managed to make the optimal decision when selecting the QEP, and all other different QEPs in the neighbouring selectivity space do not produce performance benefits.
        </p>
      );

    } 
    else {
      return (
        <div>
          <p>The estimated cost per row of the original QEP at <i><b>estimated cost = {parseFloat(props.output["data"][0]["estimated_cost_per_row"]).toFixed(3)}</b></i> generated by the input query is not the lowest among all plans that are different in the neighbouring selectivity space of the predicates that have been varied. This implies that PostgreSQL might have made a suboptimal decision when selecting the QEP. </p>
          <p>Plan {props.output["best_plan_id"]} is a different plan from the original QEP, has a lower estimated cost per row compared to the original QEP at <i><b>estimated cost = {parseFloat(props.output["data"][props.output["best_plan_id"]]["estimated_cost_per_row"]).toFixed(3)}. </b></i> It might be worth exploring Plan {props.output["best_plan_id"]} in the event that PostgreSQL made a fine-grain decision for this specific query, causing performance loss. </p>

          {/* <p>The estimated cost per row of the original QEP at <i><b>estimated cost = </b></i> generated by the input query is not the lowest among all plans that are different in the neighbouring selectivity space of the predicates that have been varied. This implies that PostgreSQL might have made a suboptimal decision when selecting the QEP. </p>
          <p>Plan {props.output["best_plan_id"]} is a different plan from the original QEP, has a lower estimated cost per row compared to the original QEP at <i><b>estimated cost = . </b></i> It might be worth exploring Plan  in the event that PostgreSQL made a fine-grain decision for this specific query, causing performance loss. </p> */}
        </div>
      )
    }
  }


  return (
    <>
      <h1 className={styles.outputHeader}>Compare Plans</h1>
      <p>Select two query execution plans to compare. We compare based on the cost per row - the total estimated cost of the query plan divided by the number of rows returned. We recognize that as the selectivity varies, the cost naturally varies. Therefore our metric allows us to normalize and compare across various selectivities somewhat fairly in a heuristic manner. The lower this value is, the better.</p>
      <p>In the comparison, we also show each plan's predicate attributes, as well as the value that they have been varied to and the corresponding selectivity.</p>
      <p>We also provide a graph of the query plan's execution, and a natural langauge explanation. Click on the nodes in the graph for more information about each node.</p>
      <hr />
      <h1 className={styles.outputHeader}>Optimal Plan</h1>
      {parseOptimalPlanExplanation()}
      <hr />
      <Form.Row>
        <Form.Group as={Col} controlId="formPlanSelector1">
          <Form.Label><b>Select plan:</b></Form.Label>
          <Form.Control as="select" value={planSelected[0]} onChange={(event) => {handleSelect(0, event)}}>
            {renderAlternativeSelector()}
          </Form.Control>
        </Form.Group>
        <Form.Group as={Col} controlId="formPlanSelector2">
          <Form.Label><b>Select plan:</b></Form.Label>
          <Form.Control as="select" value={planSelected[1]} onChange={(event) => {handleSelect(1, event)}}>
            {renderAlternativeSelector()}
          </Form.Control>
        </Form.Group>
      </Form.Row>
      <Form.Row>
        <Form.Group as={Col} controlId="formPlanComparison1">
          <PlanComparison output={props.output} planId={planSelected[0]}/>
        </Form.Group>
        <Form.Group as={Col} controlId="formPlanComparison2">
          <PlanComparison output={props.output} planId={planSelected[1]}/>
        </Form.Group>
      </Form.Row>
      <Form.Row>
        <Form.Group as={Col} controlId="formGraph1">
          <QueryVisualizer output={props.output} planId={planSelected[0]}/>
        </Form.Group>
        <Form.Group as={Col} controlId="formGraph2">
          <QueryVisualizer output={props.output} planId={planSelected[1]}/>
        </Form.Group>
      </Form.Row>
      
      <Form.Row>
        <Form.Group as={Col} controlId="formExplanation1">
          <div className={styles.explanationWrapper} >
            {parseExplanation(planSelected[0])}
          </div>
        </Form.Group>
        <Form.Group as={Col} controlId="formExplanation2">
          <div className={styles.explanationWrapper} >
            {parseExplanation(planSelected[1])}
          </div>
        </Form.Group>
      </Form.Row>
    </>
  )
}

export default FormOutput;